use std::{ops::Deref, sync::Arc, time::Duration};

use anyhow::{anyhow, Result};
use base64::{engine::general_purpose::STANDARD as STANDARD_BASE64, Engine};
use bytes::{Buf, Bytes};
use http_body_util::{BodyExt, Empty};
use hyper::{client::conn::http1, Request};
use hyper_util::rt::TokioIo;
use rustls::{ClientConfig, OwnedTrustAnchor, RootCertStore};
use serde::{de::Error, Deserialize, Deserializer, Serialize, Serializer};
use tokio::{net::TcpStream, select, time::sleep};
use tokio_rustls::TlsConnector;
use uuid::Uuid;
use webpki_roots::TLS_SERVER_ROOTS;

/// A credential of a tunnel needed to register a tunnel connection to an edge server.
///
/// Tunnel credential for a named tunnel can be obtained by directly parsing the tunnel credential file generated by cloudflared using serde_json.
/// Tunnel credential files can be found at ~/.cloudflared/xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.json.
/// They can also be obtained using the Cloudflare API, but that is outside the scope of this library.
/// Documentation for can be found at https://developers.cloudflare.com/api/operations/cloudflare-tunnel-create-a-cloudflare-tunnel.
///
/// Tunnel credential for a new quick tunnel can be obtained by calling [QuickTunnelCredential::try_cloudflare].
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct TunnelCredential {
    #[serde(alias = "AccountTag")]
    pub account_tag: String,
    #[serde(alias = "TunnelSecret", alias = "secret")]
    pub tunnel_secret: TunnelSecret,
    #[serde(alias = "TunnelID", alias = "id")]
    pub tunnel_id: Uuid,
}

#[derive(Clone, Debug)]
/// A 32 byte slice containg the tunnel secret.
///
/// It is merely a utility type for Base64 encoding / decoding and length checking.
pub struct TunnelSecret {
    secret: [u8; 32],
}

impl Serialize for TunnelSecret {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        STANDARD_BASE64.encode(self.secret).serialize(serializer)
    }
}

impl<'de> Deserialize<'de> for TunnelSecret {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let secret = String::deserialize(deserializer)?;
        match STANDARD_BASE64.decode(secret.as_str()) {
            Ok(result) => match result.try_into() {
                Ok(result) => Ok(Self { secret: result }),
                Err(error) => Err(Error::custom(format!(
                    "Expected decoded value of 32, but got {}.",
                    error.len()
                ))),
            },
            Err(error) => Err(Error::custom(error)),
        }
    }
}

impl AsRef<[u8]> for TunnelSecret {
    fn as_ref(&self) -> &[u8] {
        self.secret.as_ref()
    }
}

/// A wrapper around [TunnelCredential] that adds a hostname field to better represent a quick tunnel.
#[derive(Debug, Serialize, Deserialize)]
pub struct QuickTunnelCredential {
    #[serde(flatten)]
    credential: TunnelCredential,
    /// The hostname of the quick tunnel
    pub hostname: String,
}

impl Deref for QuickTunnelCredential {
    type Target = TunnelCredential;
    fn deref(&self) -> &Self::Target {
        &self.credential
    }
}

impl QuickTunnelCredential {
    /// Creates a new quick tunnel and return its credential by making a request to https://api.trycloudflare.com/tunnel.
    ///
    /// Quick tunnel credentials expire after (?) if (?).
    /// The connection doesn't expire even if the credential expires.
    pub async fn try_cloudflare() -> Result<Self> {
        let connector = TlsConnector::from(Arc::new(
            ClientConfig::builder()
                .with_safe_defaults()
                .with_root_certificates(RootCertStore {
                    roots: TLS_SERVER_ROOTS
                        .iter()
                        .map(|trust_anchor| {
                            OwnedTrustAnchor::from_subject_spki_name_constraints(
                                trust_anchor.subject,
                                trust_anchor.spki,
                                trust_anchor.name_constraints,
                            )
                        })
                        .collect(),
                })
                .with_no_client_auth(),
        ));
        let connecting = connector.connect(
            API_HOST.try_into()?,
            TcpStream::connect(format!("{API_HOST}:443")).await?,
        );
        let connection = connecting.await?;
        let (mut send_request, connection) = http1::handshake(TokioIo::new(connection)).await?;
        let response = select! {
            result = send_request.send_request(
                Request::post(format!("https://{API_HOST}/{API_PATH}"))
                    .header("Host", API_HOST)
                    .body(Empty::<Bytes>::new())?,
            ) => result?,
            result = async {
                if let Err(error) = connection.await {
                    Err(anyhow!("{error}"))
                } else {
                    sleep(Duration::MAX).await;
                    unreachable!()
                }
            } => result?,
        };
        let response = serde_json::from_reader::<_, CreateTunnelResponse>(
            response.collect().await?.aggregate().reader(),
        )?;
        if let Some(result) = response.result {
            Ok(result)
        } else {
            Err(anyhow!(
                "Create tunnel error(s): [\n{}]",
                response
                    .errors
                    .into_iter()
                    .map(|error| format!("\t{} {},\n", error.code, error.message))
                    .collect::<String>()
            ))
        }
    }
}

const API_HOST: &str = "api.trycloudflare.com";
const API_PATH: &str = "tunnel";

#[derive(Deserialize)]
struct CreateTunnelResponse {
    result: Option<QuickTunnelCredential>,
    errors: Vec<CreateTunnelError>,
}

#[derive(Deserialize)]
struct CreateTunnelError {
    code: u64,
    message: String,
}

#[tokio::test]
async fn try_cloudflare() {
    QuickTunnelCredential::try_cloudflare().await.unwrap();
}
